/**
 * @description classes housing various functionalities to enable printable view with omniscript
 * @author Andi Xie
 */
public with sharing class DocGenCleanup implements Database.Batchable<ContentDocument>, Queueable {
    @TestVisible
    static final String MARK_FOR_DELETE = 'mark for delete';
    static final String BATCH_NAME = 'File Cleanup Batch';
    static final String WAITING = 'WAITING';

    public String batchName {
        get {
            if(batchName == null) {
                batchName = BATCH_NAME + ' ' + UserInfo.getUserId();
            }
            return batchName;
        }
        private set;
    }

    Integer delayInminutes;
    Integer batchSize;


    public void execute(Database.BatchableContext ctx, List<ContentDocument> scope) {
        new ElevatedAccess().deleteDocs(scope);
    }

    public void finish(Database.BatchableContext ctx) {}
    
    
    public List<ContentDocument> start (Database.BatchableContext ctx) {
        return new ElevatedAccess().getDocuments();
    }

    // using Queue to overcome Identity Verification setting where data export is impacting scheduleBatch functionality
    public void execute(QueueableContext ctx) {
        List<CronTrigger> jobs = [select id, CronJobDetail.Name, State from CronTrigger WHERE STATE = :WAITING AND CronJobDetail.Name = :batchName];
        if(jobs.size() > 0) {
            return;
        }
        System.scheduleBatch(this, batchName, delayInMinutes, batchSize);
    }

    private DocGenCleanup setBatchParam(Integer delayInminutes, Integer batchSize) {
        this.delayInminutes = delayInminutes;
        this.batchSize = batchSize;
        return this;
    }

    /**
     * @description markFileForDeletionAndScheduleBatch
     * @param  contentVersionIds content version ids to mark for delete
     * @param  delayInMinutes    delay in minutes when the batch execute to cleanup batch on the files generated by doc gen
     * @param  batchSize         batchSize
     */
    @AuraEnabled
    public static void markFileForDeletionAndScheduleBatch(List<Id> contentVersionIds, Integer delayInMinutes, Integer batchSize){
        try {
           List<ContentDocument> docsToUpdate = getContentDocument(contentVersionIds);
           for(ContentDocument doc: docsToUpdate) {
               doc.Description = MARK_FOR_DELETE;
           } 
           update docsToUpdate;
           scheduleCleanupBatch(delayInMinutes, batchSize);
        } catch (Exception e) {
            throw new AuraHandledException(e.getMessage());
        }
    }


    private static void scheduleCleanupBatch(Integer delayInMinutes, Integer batchSize) {
        System.enqueueJob(new DocGenCleanup().setBatchParam(delayInMinutes, batchSize));
    }

    private static List<ContentDocument> getContentDocument(List<Id> contentVersionIds) {
        List<ContentDocument> contentDocuments = new List<ContentDocument>();
        for(Contentversion contentVersion: [SELECT ContentDocumentId FROM ContentVersion where Id IN :contentVersionIds]) {
            contentDocuments.add(new ContentDocument(Id=contentVersion.ContentDocumentId));
        } 
        return contentDocuments;
    }

 /* without sharing used here to be able to delete files that's not owned by the running user
  * thus reducing the need of scheduling multiple batches each time 
  */
  private without sharing class ElevatedAccess {
        List<ContentDocument> getDocuments() {
            return [SELECT Id FROM ContentDocument WHERE Description = :MARK_FOR_DELETE];
        }

        void deleteDocs(List<ContentDocument> docsToDelete) {
            delete docsToDelete;
        }
    }

}